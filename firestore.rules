rules_version = '2';

service cloud.firestore {
  match /databases/{db}/documents {

    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function hasRequiredFields(fields) {
      return request.resource.data.keys().hasAll(fields);
    }

    function isValidString(field, minLen, maxLen) {
      return request.resource.data[field] is string
        && request.resource.data[field].size() >= minLen
        && request.resource.data[field].size() <= maxLen;
    }

    // Timestamp must be recent (within last 5 minutes, and not too far in future)
    function isRecentTimestamp(field) {
      return request.resource.data[field] is timestamp
        && request.resource.data[field] >= request.time - duration.value(5, 'm')
        && request.resource.data[field] <= request.time + duration.value(1, 'm');
    }

    // Block client writes to protected trust/moderation fields
    function hasProtectedProfileFields(data) {
      return data.keys().hasAny([
        'trustLevel',
        'reputationScore',
        'reputationSignals',
        'isBanned',
        'banExpiresAt',
        'proVerificationStatus',
        'isProVerified'
      ]);
    }

    function isGameParticipant(gameData) {
      return isAuthenticated()
        && (gameData.player1Id == request.auth.uid || gameData.player2Id == request.auth.uid);
    }

    // =========================================================================
    // ENVIRONMENT NAMESPACED DATA
    // New data should use /env/{environment}/ prefix for isolation.
    //
    // IMPORTANT:
    // - 'local' is NOT allowed in production Firestore.
    // - Local development should use Firebase Emulator.
    //
    // NOTE:
    // Without custom claims, server-side enforcement of environment isolation is
    // limited. Client guardrails should enforce correct env usage.
    // =========================================================================

    // User profiles in environment namespace (client-writable, but protected fields server-only)
    match /env/{environment}/users/{userId} {
      allow read: if isAuthenticated();

      allow create: if isOwner(userId)
        && !hasProtectedProfileFields(request.resource.data);

      allow update: if isOwner(userId)
        && !request.resource.data.diff(resource.data).affectedKeys().hasAny([
          'trustLevel',
          'reputationScore',
          'reputationSignals',
          'isBanned',
          'banExpiresAt',
          'proVerificationStatus',
          'isProVerified'
        ]);

      allow delete: if false;
    }

    // -------------------------------------------------------------------------
    // CRITICAL FIX (Guest Mode + prod bootstrap):
    // /env/prod/... has a prod catch-all below that blocks writes to 'users'.
    // Because /env/prod is a literal path, it can override the generic /env/{environment}.
    // This explicit match ensures owner-only profile bootstrap works in prod.
    // -------------------------------------------------------------------------
    match /env/prod/users/{userId} {
      allow read: if isAuthenticated();

      allow create: if isOwner(userId)
        && !hasProtectedProfileFields(request.resource.data);

      allow update: if isOwner(userId)
        && !request.resource.data.diff(resource.data).affectedKeys().hasAny([
          'trustLevel',
          'reputationScore',
          'reputationSignals',
          'isBanned',
          'banExpiresAt',
          'proVerificationStatus',
          'isProVerified'
        ]);

      allow delete: if false;
    }

    // Staging environment: full read/write for authenticated users (except users/*, handled above)
    match /env/staging/{path=**} {
      allow read: if isAuthenticated();
      allow write: if isAuthenticated()
        && !path.matches('^users/.*');
    }

    // Production environment: read allowed for authenticated users; client writes blocked for sensitive collections
    match /env/prod/{collection}/{docId=**} {
      allow read: if isAuthenticated();

      // Block client writes to sensitive collections. These should be server-only.
      // NOTE: 'users' is blocked here, but explicitly allowed above in /env/prod/users/{userId}.
      allow write: if isAuthenticated()
        && !(collection in ['billing', 'admin', 'moderation', 'analytics_events', 'users']);
    }

    // =========================================================================
    // MODERATION (server-only via Admin SDK)
    // =========================================================================

    match /moderation_users/{userId} {
      allow read: if isAuthenticated() && request.auth.uid == userId;
      allow write: if false;
    }

    match /reports/{reportId} {
      allow read, write: if false;
    }

    match /mod_actions/{actionId} {
      allow read, write: if false;
    }

    match /moderation_quotas/{quotaId} {
      allow read, write: if false;
    }

    // =========================================================================
    // USER PROFILES - /profiles/{uid}
    // Used by Guest Mode bootstrap in some builds.
    // =========================================================================

    match /profiles/{uid} {
      allow read: if isOwner(uid);
      allow create: if isOwner(uid);
      allow update: if isOwner(uid);
      allow delete: if false;
    }

    // =========================================================================
    // MAP / SPOTS (read-only to clients)
    // =========================================================================

    match /map/{id} {
      allow read: if isAuthenticated();
      allow write: if false;
    }

    match /spots/{id} {
      allow read: if isAuthenticated();
      allow write: if false;
    }

    // Optional explicit env path for spots (still read-only)
    match /env/prod/spots/{id} {
      allow read: if isAuthenticated();
      allow write: if false;
    }

    // =========================================================================
    // DEPRECATED /users (legacy presence/compat path)
    // =========================================================================

    match /users/{userId} {
      allow read: if isAuthenticated();
      allow write: if false;
    }

    // =========================================================================
    // USER PRESENCE
    // =========================================================================

    match /presence/{userId} {
      allow read: if isAuthenticated();

      allow write: if isOwner(userId)
        && hasRequiredFields(['status', 'lastSeen'])
        && request.resource.data.status in ['online', 'offline', 'away']
        && request.resource.data.lastSeen is timestamp
        && request.resource.data.lastSeen >= request.time - duration.value(1, 'm')
        && request.resource.data.lastSeen <= request.time + duration.value(1, 'm')
        // Prevent arbitrary data injection
        && request.resource.data.keys().hasOnly(['status', 'lastSeen', 'deviceId']);
    }

    // =========================================================================
    // CHAT MESSAGES (AI Skate Buddy)
    // =========================================================================

    match /chat_messages/{messageId} {
      allow read: if isAuthenticated()
        && resource.data.userId == request.auth.uid;

      allow create: if isAuthenticated()
        && request.resource.data.userId == request.auth.uid
        && hasRequiredFields(['userId', 'message', 'role', 'createdAt'])
        && isValidString('message', 1, 5000)
        && request.resource.data.role == 'user'
        && isRecentTimestamp('createdAt')
        && messageId.matches('^' + request.auth.uid + '_.*');

      allow update: if isOwner(resource.data.userId)
        && resource.data.role == 'user'
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.role == resource.data.role
        && request.resource.data.createdAt == resource.data.createdAt
        && isValidString('message', 1, 5000)
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp);

      allow delete: if isOwner(resource.data.userId) && resource.data.role == 'user';
    }

    // =========================================================================
    // GAME SESSIONS (Real-time SKATE)
    // =========================================================================

    match /game_sessions/{gameId} {
      allow read: if isAuthenticated()
        && (resource.data.player1Id == request.auth.uid
            || resource.data.player2Id == request.auth.uid);

      allow create: if isAuthenticated()
        && hasRequiredFields(['player1Id', 'player2Id', 'currentTurn', 'status', 'createdAt'])
        && (request.resource.data.player1Id == request.auth.uid
            || request.resource.data.player2Id == request.auth.uid)
        && request.resource.data.player1Id != request.resource.data.player2Id
        && request.resource.data.status == 'waiting'
        && request.resource.data.currentTurn in [
          request.resource.data.player1Id,
          request.resource.data.player2Id
        ]
        && isRecentTimestamp('createdAt');

      allow update: if isAuthenticated()
        && isGameParticipant(resource.data)
        && (
          (resource.data.currentTurn == request.auth.uid && resource.data.status == 'active')
          || (request.auth.uid == resource.data.player2Id && resource.data.status == 'waiting')
        )
        && request.resource.data.player1Id == resource.data.player1Id
        && request.resource.data.player2Id == resource.data.player2Id
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.status in ['waiting', 'active', 'completed', 'abandoned']
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp);

      allow delete: if isAuthenticated()
        && isGameParticipant(resource.data);
    }

    // =========================================================================
    // NOTIFICATIONS
    // =========================================================================

    match /notifications/{notificationId} {
      allow read: if isAuthenticated()
        && resource.data.userId == request.auth.uid;

      allow create: if false;

      allow update: if isOwner(resource.data.userId)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt'])
        && request.resource.data.read is bool
        && (!('readAt' in request.resource.data) || request.resource.data.readAt is timestamp);

      allow delete: if isOwner(resource.data.userId);
    }

    // =========================================================================
    // ACTIVE CHECK-INS
    // =========================================================================

    match /active_checkins/{checkinId} {
      allow read: if isAuthenticated();

      allow create: if isAuthenticated()
        && hasRequiredFields(['userId', 'spotId', 'checkedInAt'])
        && request.resource.data.userId == request.auth.uid
        && isValidString('spotId', 1, 100)
        && isRecentTimestamp('checkedInAt')
        && checkinId == request.auth.uid + '_' + request.resource.data.spotId
        && (!('latitude' in request.resource.data) || request.resource.data.latitude is number)
        && (!('longitude' in request.resource.data) || request.resource.data.longitude is number)
        && (!('displayName' in request.resource.data) || isValidString('displayName', 1, 50));

      allow update: if isOwner(resource.data.userId)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.spotId == resource.data.spotId
        && request.resource.data.checkedInAt == resource.data.checkedInAt
        && (!('checkedOutAt' in request.resource.data) || request.resource.data.checkedOutAt is timestamp);

      allow delete: if isOwner(resource.data.userId);
    }

    // =========================================================================
    // CHALLENGE VOTES
    // =========================================================================

    match /challenge_votes/{voteId} {
      allow read: if isAuthenticated();

      allow create: if isAuthenticated()
        && hasRequiredFields(['userId', 'challengeId', 'submissionId', 'voteType', 'createdAt'])
        && request.resource.data.userId == request.auth.uid
        && isValidString('challengeId', 1, 100)
        && isValidString('submissionId', 1, 100)
        && request.resource.data.voteType in ['upvote', 'downvote']
        && isRecentTimestamp('createdAt')
        && voteId == request.auth.uid + '_' + request.resource.data.submissionId;

      allow update: if isOwner(resource.data.userId)
        && request.resource.data.userId == resource.data.userId
        && request.resource.data.challengeId == resource.data.challengeId
        && request.resource.data.submissionId == resource.data.submissionId
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.voteType in ['upvote', 'downvote']
        && request.resource.data.voteType != resource.data.voteType
        && (!('updatedAt' in request.resource.data) || request.resource.data.updatedAt is timestamp);

      allow delete: if isOwner(resource.data.userId);
    }

    // =========================================================================
    // LIVE LEADERBOARD (server-written)
    // =========================================================================

    match /leaderboard_live/{userId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if false;
    }

    // =========================================================================
    // LEGACY COLLECTIONS
    // =========================================================================

    // Enhanced signup security (unauth allowed)
    match /signups/{doc} {
      allow create: if
        // Email validation
        request.resource.data.email is string
        && request.resource.data.email.size() > 3
        && request.resource.data.email.size() < 254
        && request.resource.data.email.matches('^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$')

        // Source validation
        && request.resource.data.source in ['site', 'app', 'landing']

        // Timestamp validation
        && request.resource.data.createdAt == request.time

        // Honeypot validation
        && (!('company' in request.resource.data) || request.resource.data.company == '')

        // Strict field allowlist
        && request.resource.data.keys().hasOnly(['email', 'source', 'createdAt', 'userAgent', 'timestamp'])

        && (!('userAgent' in request.resource.data) || request.resource.data.userAgent is string)
        && (!('timestamp' in request.resource.data) || request.resource.data.timestamp is number)

        // Rate limiting (only enforce if authenticated; avoid null auth crashes)
        && (
          !isAuthenticated()
          || !exists(/databases/$(db)/documents/signups/$(request.auth.uid))
          || get(/databases/$(db)/documents/signups/$(request.auth.uid)).data.createdAt < request.time - duration.value(1, 'm')
        );

      allow read, update, delete: if false;
    }

    match /mail/{doc} {
      allow read, write: if false;
    }

    match /mail_list/{docId} {
      allow read, write: if false;
    }

    match /subscriptions/{document} {
      allow read, write: if false;
    }

    // =========================================================================
    // REMOTE S.K.A.T.E. CHALLENGES
    // =========================================================================

    match /challenges/{challengeId} {
      allow read: if isAuthenticated()
        && (resource.data.createdBy == request.auth.uid
            || resource.data.opponent == request.auth.uid
            || request.auth.uid in resource.data.participants);

      allow create: if isAuthenticated()
        && hasRequiredFields(['createdBy', 'opponent', 'participants', 'rules', 'status', 'createdAt'])
        && request.resource.data.createdBy == request.auth.uid
        && request.resource.data.opponent != request.auth.uid
        && request.resource.data.participants.size() == 2
        && request.auth.uid in request.resource.data.participants
        && request.resource.data.opponent in request.resource.data.participants

        && request.resource.data.rules.oneTake == true
        && request.resource.data.rules.durationSec == 15

        && request.resource.data.clipA.createdBy == request.auth.uid
        && request.resource.data.clipA.durationSec >= 14.5
        && request.resource.data.clipA.durationSec <= 15.5
        && request.resource.data.clipA.url is string
        && request.resource.data.clipA.url.size() >= 1
        && request.resource.data.clipA.url.size() <= 2000

        && request.resource.data.status == 'pending'
        && isRecentTimestamp('createdAt');

      allow update: if isAuthenticated()
        && (
          (resource.data.opponent == request.auth.uid
           && resource.data.status == 'pending'
           && request.resource.data.status == 'active'
           && 'clipB' in request.resource.data
           && request.resource.data.clipB.createdBy == request.auth.uid
           && request.resource.data.clipB.durationSec >= 14.5
           && request.resource.data.clipB.durationSec <= 15.5
           && request.resource.data.clipB.url is string
           && request.resource.data.clipB.url.size() >= 1
           && request.resource.data.clipB.url.size() <= 2000)
          ||
          (resource.data.createdBy == request.auth.uid
           && resource.data.status == 'pending'
           && request.resource.data.status == 'cancelled')
        )
        && request.resource.data.createdBy == resource.data.createdBy
        && request.resource.data.opponent == resource.data.opponent
        && request.resource.data.participants == resource.data.participants
        && request.resource.data.rules == resource.data.rules
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.clipA == resource.data.clipA;

      allow delete: if isAuthenticated()
        && resource.data.createdBy == request.auth.uid
        && resource.data.status == 'pending';
    }

    // =========================================================================
    // DEFAULT DENY
    // =========================================================================

    match /{document=**} {
      allow read, write: if false;
    }
  }
}
